module iec104;

import spicy;


%byte-order = spicy::ByteOrder::Little;

# Not used for parsing.
public type Format = enum {
    I = 0,
    S = 1,
    U = 3
};

public type TypeID = enum {
    ASDU_TYPEUNDEF =   0, # Not allowed
    M_SP_NA_1      =   1, # Single-point information
    M_SP_TA_1      =   2, # Single-point information with time tag
    M_DP_NA_1      =   3, # Double-point information
    M_DP_TA_1      =   4, # Double-point information with time tag
    M_ST_NA_1      =   5, # Step position information
    M_ST_TA_1      =   6, # Step position information with time tag
    M_BO_NA_1      =   7, # Bitstring of 32 bit
    M_BO_TA_1      =   8, # Bitstring of 32 bit with time tag
    M_ME_NA_1      =   9, # Measured value, normalised value
    M_ME_TA_1      =  10, # Measured value, normalized value with time tag
    M_ME_NB_1      =  11, # Measured value, scaled value
    M_ME_TB_1      =  12, # Measured value, scaled value wit time tag
    M_ME_NC_1      =  13, # Measured value, short floating point number
    M_ME_TC_1      =  14, # Measured value, short floating point number with time tag
    M_IT_NA_1      =  15, # Integrated totals
    M_IT_TA_1      =  16, # Integrated totals with time tag
    M_EP_TA_1      =  17, # Event of protection equipment with time tag
    M_EP_TB_1      =  18, # Packed start events of protection equipment with time tag
    M_EP_TC_1      =  19, # Packed output circuit information of protection equipment with time tag
    M_PS_NA_1      =  20, # Packed single point information with status change detection
    M_ME_ND_1      =  21, # Measured value, normalized value without quality descriptor
    ASDU_TYPE_22   =  22,
    ASDU_TYPE_23   =  23,
    ASDU_TYPE_24   =  24,
    ASDU_TYPE_25   =  25,
    ASDU_TYPE_26   =  26,
    ASDU_TYPE_27   =  27,
    ASDU_TYPE_28   =  28,
    ASDU_TYPE_29   =  29,
    M_SP_TB_1      =  30, # Single-point information with time tag CP56Time2a
    M_DP_TB_1      =  31, # Double-point information with time tag CP56Time2a
    M_ST_TB_1      =  32, # Step position information with time tag CP56Time2a
    M_BO_TB_1      =  33, # Bitstring of 32 bit with time tag CP56Time2a
    M_ME_TD_1      =  34, # Measured value, normalised value with time tag CP56Time2a
    M_ME_TE_1      =  35, # Measured value, scaled value with time tag CP56Time2a
    M_ME_TF_1      =  36, # Measured value, short floating point number with time tag CP56Time2a
    M_IT_TB_1      =  37, # Integrated totals with time tag CP56Time2a
    M_EP_TD_1      =  38, # Event of protection equipment with time tag CP56Time2a
    M_EP_TE_1      =  39, # Packed start events of protection equipment with time tag CP56Time2a
    M_EP_TF_1      =  40, # Packed output circuit information of protection equipment with time tag CP56Time2a
    ASDU_TYPE_41   =  41,
    ASDU_TYPE_42   =  42,
    ASDU_TYPE_43   =  43,
    ASDU_TYPE_44   =  44,
    C_SC_NA_1      =  45, # Single command
    C_DC_NA_1      =  46, # Double command
    C_RC_NA_1      =  47, # Regulating step command
    C_SE_NA_1      =  48, # Set-point Command, normalised value
    C_SE_NB_1      =  49, # Set-point Command, scaled value
    C_SE_NC_1      =  50, # Set-point Command, short floating point number
    C_BO_NA_1      =  51, # Bitstring 32 bit command
    ASDU_TYPE_52   =  52,
    ASDU_TYPE_53   =  53,
    ASDU_TYPE_54   =  54,
    ASDU_TYPE_55   =  55,
    ASDU_TYPE_56   =  56,
    ASDU_TYPE_57   =  57,
    C_SC_TA_1      =  58, # Single command with time tag CP56Time2a
    C_DC_TA_1      =  59, # Double command with time tag CP56Time2a
    C_RC_TA_1      =  60, # Regulating step command with time tag CP56Time2a
    C_SE_TA_1      =  61, # Measured value, normalised value command with time tag CP56Time2a
    C_SE_TB_1      =  62, # Measured value, scaled value command with time tag CP56Time2a
    C_SE_TC_1      =  63, # Measured value, short floating point number command with time tag CP56Time2a
    C_BO_TA_1      =  64, # Bitstring of 32 bit command with time tag CP56Time2a
    ASDU_TYPE_65   =  65,
    ASDU_TYPE_66   =  66,
    ASDU_TYPE_67   =  67,
    ASDU_TYPE_68   =  68,
    ASDU_TYPE_69   =  69,
    M_EI_NA_1      =  70, # End of Initialisation
    ASDU_TYPE_71   =  71,
    ASDU_TYPE_72   =  72,
    ASDU_TYPE_73   =  73,
    ASDU_TYPE_74   =  74,
    ASDU_TYPE_75   =  75,
    ASDU_TYPE_76   =  76,
    ASDU_TYPE_77   =  77,
    ASDU_TYPE_78   =  78,
    ASDU_TYPE_79   =  79,
    ASDU_TYPE_80   =  80,
    ASDU_TYPE_81   =  81,
    ASDU_TYPE_82   =  82,
    ASDU_TYPE_83   =  83,
    ASDU_TYPE_84   =  84,
    ASDU_TYPE_85   =  85,
    ASDU_TYPE_86   =  86,
    ASDU_TYPE_87   =  87,
    ASDU_TYPE_88   =  88,
    ASDU_TYPE_89   =  89,
    ASDU_TYPE_90   =  90,
    ASDU_TYPE_91   =  91,
    ASDU_TYPE_92   =  92,
    ASDU_TYPE_93   =  93,
    ASDU_TYPE_94   =  94,
    ASDU_TYPE_95   =  95,
    ASDU_TYPE_96   =  96,
    ASDU_TYPE_97   =  97,
    ASDU_TYPE_98   =  98,
    ASDU_TYPE_99   =  99,
    C_IC_NA_1      = 100, # Interrogation command
    C_CI_NA_1      = 101, # Counter interrogation command
    C_RD_NA_1      = 102, # Read Command
    C_CS_NA_1      = 103, # Clock synchronisation command
    C_TS_NA_1      = 104, # Test command
    C_RP_NA_1      = 105, # Reset process command
    C_CD_NA_1      = 106, # C_CD_NA_1 Delay acquisition command
    C_TS_TA_1      = 107, # Test command with time tag CP56Time2a
    ASDU_TYPE_108  = 108,
    ASDU_TYPE_109  = 109,
    P_ME_NA_1      = 110, # Parameter of measured values, normalized value
    P_ME_NB_1      = 111, # Parameter of measured values, scaled value
    P_ME_NC_1      = 112, # Parameter of measured values, short floating point number
    P_AC_NA_1      = 113, # Parameter activation
    ASDU_TYPE_114  = 114,
    ASDU_TYPE_115  = 115,
    ASDU_TYPE_116  = 116,
    ASDU_TYPE_117  = 117,
    ASDU_TYPE_118  = 118,
    ASDU_TYPE_119  = 119,
    F_FR_NA_1      = 120, # File ready
    F_SR_NA_1      = 121, # Section ready
    F_SC_NA_1      = 122, # Call directory, select file, call file, call section
    F_LS_NA_1      = 123, # Last section, last segment
    F_AF_NA_1      = 124, # ACK file, ACK section
    F_SG_NA_1      = 125, # Segment
    F_DR_TA_1      = 126, # Directory
    F_SC_NB_1      = 127, # QueryLog - request archive file

    # Reserved user ASDU types.
    ASDU_TYPE_128  = 128,
    ASDU_TYPE_129  = 129,
    ASDU_TYPE_130  = 130,
    ASDU_TYPE_131  = 131,
    ASDU_TYPE_132  = 132,
    ASDU_TYPE_133  = 133,
    ASDU_TYPE_134  = 134,
    ASDU_TYPE_135  = 135,
    ASDU_TYPE_136  = 136,
    ASDU_TYPE_137  = 137,
    ASDU_TYPE_138  = 138,
    ASDU_TYPE_139  = 139,
    ASDU_TYPE_140  = 140,
    ASDU_TYPE_141  = 141,
    ASDU_TYPE_142  = 142,
    ASDU_TYPE_143  = 143,
    ASDU_TYPE_144  = 144,
    ASDU_TYPE_145  = 145,
    ASDU_TYPE_146  = 146,
    ASDU_TYPE_147  = 147,
    ASDU_TYPE_148  = 148,
    ASDU_TYPE_149  = 149,
    ASDU_TYPE_150  = 150,
    ASDU_TYPE_151  = 151,
    ASDU_TYPE_152  = 152,
    ASDU_TYPE_153  = 153,
    ASDU_TYPE_154  = 154,
    ASDU_TYPE_155  = 155,
    ASDU_TYPE_156  = 156,
    ASDU_TYPE_157  = 157,
    ASDU_TYPE_158  = 158,
    ASDU_TYPE_159  = 159,
    ASDU_TYPE_160  = 160,
    ASDU_TYPE_161  = 161,
    ASDU_TYPE_162  = 162,
    ASDU_TYPE_163  = 163,
    ASDU_TYPE_164  = 164,
    ASDU_TYPE_165  = 165,
    ASDU_TYPE_166  = 166,
    ASDU_TYPE_167  = 167,
    ASDU_TYPE_168  = 168,
    ASDU_TYPE_169  = 169,
    ASDU_TYPE_170  = 170,
    ASDU_TYPE_171  = 171,
    ASDU_TYPE_172  = 172,
    ASDU_TYPE_173  = 173,
    ASDU_TYPE_174  = 174,
    ASDU_TYPE_175  = 175,
    ASDU_TYPE_176  = 176,
    ASDU_TYPE_177  = 177,
    ASDU_TYPE_178  = 178,
    ASDU_TYPE_179  = 179,
    ASDU_TYPE_180  = 180,
    ASDU_TYPE_181  = 181,
    ASDU_TYPE_182  = 182,
    ASDU_TYPE_183  = 183,
    ASDU_TYPE_184  = 184,
    ASDU_TYPE_185  = 185,
    ASDU_TYPE_186  = 186,
    ASDU_TYPE_187  = 187,
    ASDU_TYPE_188  = 188,
    ASDU_TYPE_189  = 189,
    ASDU_TYPE_190  = 190,
    ASDU_TYPE_191  = 191,
    ASDU_TYPE_192  = 192,
    ASDU_TYPE_193  = 193,
    ASDU_TYPE_194  = 194,
    ASDU_TYPE_195  = 195,
    ASDU_TYPE_196  = 196,
    ASDU_TYPE_197  = 197,
    ASDU_TYPE_198  = 198,
    ASDU_TYPE_199  = 199,
    ASDU_TYPE_200  = 200,
    ASDU_TYPE_201  = 201,
    ASDU_TYPE_202  = 202,
    ASDU_TYPE_203  = 203,
    ASDU_TYPE_204  = 204,
    ASDU_TYPE_205  = 205,
    ASDU_TYPE_206  = 206,
    ASDU_TYPE_207  = 207,
    ASDU_TYPE_208  = 208,
    ASDU_TYPE_209  = 209,
    ASDU_TYPE_210  = 210,
    ASDU_TYPE_211  = 211,
    ASDU_TYPE_212  = 212,
    ASDU_TYPE_213  = 213,
    ASDU_TYPE_214  = 214,
    ASDU_TYPE_215  = 215,
    ASDU_TYPE_216  = 216,
    ASDU_TYPE_217  = 217,
    ASDU_TYPE_218  = 218,
    ASDU_TYPE_219  = 219,
    ASDU_TYPE_220  = 220,
    ASDU_TYPE_221  = 221,
    ASDU_TYPE_222  = 222,
    ASDU_TYPE_223  = 223,
    ASDU_TYPE_224  = 224,
    ASDU_TYPE_225  = 225,
    ASDU_TYPE_226  = 226,
    ASDU_TYPE_227  = 227,
    ASDU_TYPE_228  = 228,
    ASDU_TYPE_229  = 229,
    ASDU_TYPE_230  = 230,
    ASDU_TYPE_231  = 231,
    ASDU_TYPE_232  = 232,
    ASDU_TYPE_233  = 233,
    ASDU_TYPE_234  = 234,
    ASDU_TYPE_235  = 235,
    ASDU_TYPE_236  = 236,
    ASDU_TYPE_237  = 237,
    ASDU_TYPE_238  = 238,
    ASDU_TYPE_239  = 239,
    ASDU_TYPE_240  = 240,
    ASDU_TYPE_241  = 241,
    ASDU_TYPE_242  = 242,
    ASDU_TYPE_243  = 243,
    ASDU_TYPE_244  = 244,
    ASDU_TYPE_245  = 245,
    ASDU_TYPE_246  = 246,
    ASDU_TYPE_247  = 247,
    ASDU_TYPE_248  = 248,
    ASDU_TYPE_249  = 249,
    ASDU_TYPE_250  = 250,
    ASDU_TYPE_251  = 251,
    ASDU_TYPE_252  = 252,
    ASDU_TYPE_253  = 253,
    ASDU_TYPE_254  = 254,
    ASDU_TYPE_255  = 255
};

public type CoT = enum {
    Cot_Unused  =  0, # Is not used
    Percyc      =  1, # Cyclic data
    Back        =  2, # Background scan
    Spont       =  3, # Spontaneous data
    Init        =  4, # End of initialization
    Req         =  5, # Read request
    Act         =  6, # Command activation
    Actcon      =  7, # Confirmation of command activation
    Deact       =  8, # Command abortion
    Deactcon    =  9, # Confirmation of command abortion
    ActTerm     = 10, # Termination of command activation
    Retrem      = 11, # Response due to remote command
    Retloc      = 12, # Response due to local command
    File        = 13, # File access
    Auth        = 14, # Authentication
    Seskey      = 15, # Authentication session key maintenance
    Usrkey      = 16, # User role and update key maintenance
    Cot_17      = 17,
    Cot_18      = 18,
    Cot_19      = 19,
    Inrogen     = 20, # Station interrogation (general)
    Inro1       = 21, # Station interrogation for group 1
    Inro2       = 22, # Station interrogation for group 2
    Inro3       = 23, # Station interrogation for group 3
    Inro4       = 24, # Station interrogation for group 4
    Inro5       = 25, # Station interrogation for group 5
    Inro6       = 26, # Station interrogation for group 6
    Inro7       = 27, # Station interrogation for group 7
    Inro8       = 28, # Station interrogation for group 8
    Inro9       = 29, # Station interrogation for group 9
    Inro10      = 30, # Station interrogation for group 10
    Inro11      = 31, # Station interrogation for group 11
    Inro12      = 32, # Station interrogation for group 12
    Inro13      = 33, # Station interrogation for group 13
    Inro14      = 34, # Station interrogation for group 14
    Inro15      = 35, # Station interrogation for group 15
    Inro16      = 36, # Station interrogation for group 16
    Reqcogen    = 37, # Counter interrogation (general)
    Reqco1      = 38, # Counter interrogation for group 1
    Reqco2      = 39, # Counter interrogation for group 2
    Reqco3      = 40, # Counter interrogation for group 3
    Reqco4      = 41, # Counter interrogation for group 4
    Cot_42      = 42,
    Cot_43      = 43,
    UnkType     = 44, # Unknown type
    UnkCause    = 45, # Unknown cause of transfer
    UnkAsduAddr = 46, # Unknown common ASDU address
    UnkObjAddr  = 47, # Unknown object address
    Cot_48      = 48,
    Cot_49      = 49,
    Cot_50      = 50,
    Cot_51      = 51,
    Cot_52      = 52,
    Cot_53      = 53,
    Cot_54      = 54,
    Cot_55      = 55,
    Cot_56      = 56,
    Cot_57      = 57,
    Cot_58      = 58,
    Cot_59      = 59,
    Cot_60      = 60,
    Cot_61      = 61,
    Cot_62      = 62,
    Cot_63      = 63
};

type SIQ = unit {
    : bitfield(8) {
        spi: 0;
        # : 1..3 = 0;
        bl: 4;
        sb: 5;
        nt: 6;
        iv: 7;
    };
};

type DIQ = unit {
    : bitfield(8) {
        dpi: 0..1;
        # : 2..3 = 0;
        bl: 4;
        sb: 5;
        nt: 6;
        iv: 7;
    };
};

type QD = unit {
    : bitfield(8) {
        sq: 0..4;
        cy: 5;
        ca: 6;
        iv: 7;
    };
};

type QDS = unit {
    : bitfield(8) {
        ov: 0;
        # : 1..3 = 0;
        bl: 4;
        sb: 5;
        nt: 6;
        iv: 7;
    };
};

type SEP = unit {
    : bitfield(8) {
        es: 0..1;
        # : 2 = 0;
        ei: 3;
        bl: 4;
        sb: 5;
        nt: 6;
        iv: 7;
    };
};

type QDP = unit {
    : bitfield(8) {
        # : 0..2 = 0;
        ei: 3;
        bl: 4;
        sb: 5;
        nt: 6;
        iv: 7;
    };
};

type SEPstart = unit {
    : bitfield(8) {
        gs: 0;
        sl1: 1;
        sl2: 2;
        sl3: 3;
        sie: 4;
        srd: 5;
        # : 6..7 = 0;
    };
};

type OCI = unit {
    : bitfield(8) {
        gc: 0;
        cl1: 1;
        cl2: 2;
        cl3: 3;
        # : 4..7 = 0;
    };
};

type SCO = unit {
    : bitfield(8) {
        scs: 0;
        # : 1 = 0;
        qu: 2..6;
        se: 7;
    };
};

type DCO = unit {
    : bitfield(8) {
        dcs: 0..1;
        qu: 2..6;
        se: 7;
    };
};

type RCO = unit {
    : bitfield(8) {
        rcs: 0..1;
        qu: 2..6;
        se: 7;
    };
};

type QOS = unit {
    : bitfield(8) {
        ql: 0..6;
        se: 7;
    };
};

type VTI = unit {
    : bitfield(8) {
        val: 0..6;
        ts: 7;
    };
};

type QCC = unit {
    : bitfield(8) {
        rqt: 0..5;
        frz: 6..7;
    };
};

type QPM = unit {
    : bitfield(8) {
        kpa: 0..5;
        pop: 6;
        lpc: 7;
    };
};

type CP24Time2a = unit {
    ms: uint16;
    : bitfield(8) {
        minute: 0..5;
        # : 6 = 0;
        iv: 7;
    };
};

type CP56Time2a = unit {
    ms: uint16;
    : bitfield(8) {
        minute: 0..5;
        # : 6 = 0;
        iv: 7;
    };
    : bitfield(8) {
        hour: 0..4;
        # : 5..6 = 0;
        su: 7;
    };
    : bitfield(8) {
        day: 0..4;
        dow: 5..7;
    };
    : bitfield(8) {
        month: 0..3;
        # : 4..7 = 0;
    };
    : bitfield(8) {
        year: 0..6;
        # : 7 = 0;
    };
};

################################################################################

type M_SP_NA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    siq: SIQ;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_SP_TA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    siq: SIQ;
    tt: CP24Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_DP_NA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    diq: DIQ;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_DP_TA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    diq: DIQ;
    tt: CP24Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_ST_NA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    vti: VTI;
    qds: QDS;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_ST_TA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    vti: VTI;
    qds: QDS;
    tt: CP24Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_BO_NA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    bsi: uint32 &byte-order=spicy::ByteOrder::Big;
    qds: QDS;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_BO_TA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    bsi: uint32 &byte-order=spicy::ByteOrder::Big;
    qds: QDS;
    tt: CP24Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_ME_NA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    nva: uint16;
    qds: QDS;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_ME_NB_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    sva: uint16;
    qds: QDS;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_ME_TB_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    sva: uint16;
    qds: QDS;
    tt: CP24Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_ME_TA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    nva: uint16;
    qds: QDS;
    tt: CP24Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_ME_NC_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    r32: real &type=spicy::RealType::IEEE754_Single;
    qds: QDS;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_ME_TC_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    r32: real &type=spicy::RealType::IEEE754_Single;
    qds: QDS;
    tt: CP24Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_IT_NA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    bcr: uint32;
    qd: QD;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_IT_TA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    bcr: uint32;
    qd: QD;
    tt: CP24Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_PS_NA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    scd: uint32;
    qds: QDS;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_ME_ND_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    nva: uint16;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_SP_TB_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    siq: SIQ;
    tt: CP56Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_DP_TB_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    diq: DIQ;
    tt: CP56Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_ST_TB_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    vti: VTI;
    qds: QDS;
    tt: CP56Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_BO_TB_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    bsi: uint32 &byte-order=spicy::ByteOrder::Big;
    qds: QDS;
    tt: CP56Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_ME_TD_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    nva: uint16;
    qds: QDS;
    tt: CP56Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_ME_TE_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    sva: uint16;
    qds: QDS;
    tt: CP56Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_ME_TF_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    r32: real &type=spicy::RealType::IEEE754_Single;
    qds: QDS;
    tt: CP56Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_IT_TB_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    bcr: uint32;
    qd: QD;
    tt: CP56Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_EP_TD_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    sep: SEP;
    # Theoretically this is a CP16Time2a, but not making a separate
    # unit just for a single value (yet).
    ms: uint16;
    tt: CP56Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_EP_TE_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    sep: SEPstart;
    qdp: QDP;
    ms: uint16;
    tt: CP56Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_EP_TF_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    oci: OCI;
    qdp: QDP;
    ms: uint16;
    tt: CP56Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type C_SC_NA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    sco: SCO;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type C_DC_NA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    dco: DCO;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type C_RC_NA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    rco: RCO;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type C_SE_NA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    nva: uint16;
    qos: QOS;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type C_SE_NB_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    sva: uint16;
    qos: QOS;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type C_SE_NC_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    r32: real &type=spicy::RealType::IEEE754_Single;
    qos: QOS;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type C_BO_NA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    bsi: uint32 &byte-order=spicy::ByteOrder::Big;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type C_SC_TA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    sco: SCO;
    tt: CP56Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type C_DC_TA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    dco: DCO;
    tt: CP56Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type C_RC_TA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    rco: RCO;
    tt: CP56Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type C_SE_TA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    nva: uint16;
    qos: QOS;
    tt: CP56Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type C_SE_TB_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    sva: uint16;
    qos: QOS;
    tt: CP56Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type C_SE_TC_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    r32: real &type=spicy::RealType::IEEE754_Single;
    qos: QOS;
    tt: CP56Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type C_BO_TA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    bsi: uint32 &byte-order=spicy::ByteOrder::Big;
    tt: CP56Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type M_EI_NA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    : bitfield(8) {
        coi: 0..6;
        lpc: 7;
    };

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type C_IC_NA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    qoi: uint8;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type C_CI_NA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    qcc: QCC;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

# Theoretically C_RD_NA_1_io could be defined as follows (ignoring the
# SEQ stuff):
#
#     type C_RD_NA_1_io = unit(pn: uint8) {
#         obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little);
#         raw_data: uint8 if (pn == 0);
#     };
#
# But this does not work in the case when raw_data field must not be
# parsed (pn == 1 case).  This seems to be because the generated
# parser seems to be checking for end of input before proceeding to
# the next field, even if it turns out the field condition fails and
# the field should not be parsed. Of course this is only a problem if
# the optional field is at the end of unit (which it is in this case).
#
# The solution implemented here is removing the condition by
# open-coding both condition branches.  This also means that the event
# file has two entries for this one unit.
#
# Sequence of C_RD_NA_1 records only makes sense in the presence of
# raw_data field.
type C_RD_NA_1_xx = unit(inout id: AsduIdent) {
    a: C_RD_NA_1_io_a(id) if (id.pn == 0);
    b: C_RD_NA_1_io_b if (id.pn == 1);
};

type C_RD_NA_1_io_a = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    raw_data: uint8;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type C_RD_NA_1_io_b = unit {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little);
};

type C_CS_NA_1_io = unit {
    # XXX: obj_addr should always be 0?
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little);
    tt: CP56Time2a;
};

type C_RP_NA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    qrp: uint8;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type C_TS_TA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    tsc: uint8;
    tt: CP56Time2a;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type P_ME_NA_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    nva: uint16;
    qpm: QPM;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

type P_ME_NB_1_io = unit(inout id: AsduIdent) {
    obj_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (!id.sq);
    sva: uint16;
    qpm: QPM;

    var oa: uint64;
    on %done {
        self.oa = id.sq ? id.next_addr++ : self.obj_addr;
    }
};

################################################################################


public type Apdus = unit {
    %port = 2404/tcp &originator;
    : (Apdu &synchronize)[];
};

public type Apdu = unit {
    : int8(0x68);
    len: uint8 {
        if ($$ < 4) reject;
    }
    ctrl: Ctrl(self);

    # TODO: Check that the size of information object is (len - 4).
    : Asdu(self) if (Format::I == self.format);

    var format: Format;

    on %done { spicy::accept_input(); }
};

type Ctrl = unit(apdu: Apdu) {
    xx: uint32 { self.set_input(self.start); }

    i: Ctrl_i(apdu) if (4 < apdu.len);
    s: Ctrl_s(apdu) if (4 == apdu.len && 1 == self.xx & 0x03);
    u: Ctrl_u(apdu) if (4 == apdu.len && 3 == self.xx & 0x03);

    var start: iterator<stream>;
    on %init {
        self.start = self.input();
    }
};

public type Ctrl_i = unit(inout apdu: Apdu) {
    : bitfield(32) {
      tag: 0 = 0;
      ssn: 1..15;
      unused: 16 = 0;
      rsn: 17..31;
    };

    on %done {
        apdu.format = Format::I;
    }
};

public type Ctrl_s = unit(inout apdu: Apdu) {
    : bitfield(32) {
      tag: 0..1 = 1;
      unused: 2..16 = 0;
      rsn: 17..31;
    };

    on %done {
        apdu.format = Format::S;
    }
};

public type Ctrl_u = unit(inout apdu: Apdu) {
    : bitfield(32) {
      tag: 0..1 = 3;
      startdt: 2..3;
      stopdt: 4..5;
      testfr: 6..7;
      unused: 8..31 = 0;
    };

    on %done {
        apdu.format = Format::U;
    }
};

type Asdu = unit(apdu: Apdu) {
    id: AsduIdent;
    ios: AsduIOs(apdu, self.id);
};

type AsduIdent = unit {
   type_id: uint8 &convert=TypeID($$);
    : bitfield (8) {
        nobj: 0..6;
        sq: 7;
    };
    : bitfield (8) {
        cot: 0..5 &convert=CoT($$);
        pn: 6;
        test: 7;
    };
    originator_address: uint8;
    common_address: uint16;

    var next_addr: uint64 = 0;
};

type AsduIOs = unit(apdu: Apdu, inout id: AsduIdent) {
    var start: iterator<stream>;
    on %init {
        self.start = self.input();
    }

    base_addr: bytes &size=3 &convert=$$.to_uint(spicy::ByteOrder::Little) if (id.sq);

    on base_addr {
       id.next_addr = self.base_addr;
    }

    switch (id.type_id) {
        TypeID::M_SP_NA_1 -> m_sp_na_1: M_SP_NA_1_io(id)[id.nobj];
        TypeID::M_SP_TA_1 -> m_sp_ta_1: M_SP_TA_1_io(id)[id.nobj];
        TypeID::M_DP_NA_1 -> m_dp_na_1: M_DP_NA_1_io(id)[id.nobj];
        TypeID::M_DP_TA_1 -> m_dp_ta_1: M_DP_TA_1_io(id)[id.nobj];
        TypeID::M_ST_NA_1 -> m_st_na_1: M_ST_NA_1_io(id)[id.nobj];
        TypeID::M_ST_TA_1 -> m_st_ta_1: M_ST_TA_1_io(id)[id.nobj];
        TypeID::M_BO_NA_1 -> m_bo_na_1: M_BO_NA_1_io(id)[id.nobj];
        TypeID::M_BO_TA_1 -> m_bo_ta_1: M_BO_TA_1_io(id)[id.nobj];
        TypeID::M_ME_NA_1 -> m_me_na_1: M_ME_NA_1_io(id)[id.nobj];
        TypeID::M_ME_TA_1 -> m_me_ta_1: M_ME_TA_1_io(id)[id.nobj];
        TypeID::M_ME_NB_1 -> m_me_nb_1: M_ME_NB_1_io(id)[id.nobj];
        TypeID::M_ME_TB_1 -> m_me_tb_1: M_ME_TB_1_io(id)[id.nobj];
        TypeID::M_ME_NC_1 -> m_me_nc_1: M_ME_NC_1_io(id)[id.nobj];
        TypeID::M_ME_TC_1 -> m_me_tc_1: M_ME_TC_1_io(id)[id.nobj];
        TypeID::M_IT_NA_1 -> m_it_na_1: M_IT_NA_1_io(id)[id.nobj];
        TypeID::M_IT_TA_1 -> m_it_ta_1: M_IT_TA_1_io(id)[id.nobj];
        TypeID::M_PS_NA_1 -> m_ps_na_1: M_PS_NA_1_io(id)[id.nobj];
        TypeID::M_ME_ND_1 -> m_me_nd_1: M_ME_ND_1_io(id)[id.nobj];
        TypeID::M_SP_TB_1 -> m_sp_tb_1: M_SP_TB_1_io(id)[id.nobj];
        TypeID::M_DP_TB_1 -> m_dp_tb_1: M_DP_TB_1_io(id)[id.nobj];
        TypeID::M_ST_TB_1 -> m_st_tb_1: M_ST_TB_1_io(id)[id.nobj];
        TypeID::M_BO_TB_1 -> m_bo_tb_1: M_BO_TB_1_io(id)[id.nobj];
        TypeID::M_ME_TD_1 -> m_me_td_1: M_ME_TD_1_io(id)[id.nobj];
        TypeID::M_ME_TE_1 -> m_me_te_1: M_ME_TE_1_io(id)[id.nobj];
        TypeID::M_ME_TF_1 -> m_me_tf_1: M_ME_TF_1_io(id)[id.nobj];
        TypeID::M_IT_TB_1 -> m_it_tb_1: M_IT_TB_1_io(id)[id.nobj];
        TypeID::M_EP_TD_1 -> m_ep_td_1: M_EP_TD_1_io(id)[id.nobj];
        TypeID::M_EP_TE_1 -> m_ep_te_1: M_EP_TE_1_io(id)[id.nobj];
        TypeID::M_EP_TF_1 -> m_ep_tf_1: M_EP_TF_1_io(id)[id.nobj];
        TypeID::C_SC_NA_1 -> c_sc_na_1: C_SC_NA_1_io(id)[id.nobj];
        TypeID::C_DC_NA_1 -> c_dc_na_1: C_DC_NA_1_io(id)[id.nobj];
        TypeID::C_RC_NA_1 -> c_rc_na_1: C_RC_NA_1_io(id)[id.nobj];
        TypeID::C_SE_NA_1 -> c_se_na_1: C_SE_NA_1_io(id)[id.nobj];
        TypeID::C_SE_NB_1 -> c_se_nb_1: C_SE_NB_1_io(id)[id.nobj];
        TypeID::C_SE_NC_1 -> c_se_nc_1: C_SE_NC_1_io(id)[id.nobj];
        TypeID::C_BO_NA_1 -> c_bo_na_1: C_BO_NA_1_io(id)[id.nobj];
        TypeID::C_SC_TA_1 -> c_sc_ta_1: C_SC_TA_1_io(id)[id.nobj];
        TypeID::C_DC_TA_1 -> c_dc_ta_1: C_DC_TA_1_io(id)[id.nobj];
        TypeID::C_RC_TA_1 -> c_rc_ta_1: C_RC_TA_1_io(id)[id.nobj];
        TypeID::C_SE_TA_1 -> c_se_ta_1: C_SE_TA_1_io(id)[id.nobj];
        TypeID::C_SE_TB_1 -> c_se_tb_1: C_SE_TB_1_io(id)[id.nobj];
        TypeID::C_SE_TC_1 -> c_se_tc_1: C_SE_TC_1_io(id)[id.nobj];
        TypeID::C_BO_TA_1 -> c_bo_ta_1: C_BO_TA_1_io(id)[id.nobj];
        TypeID::M_EI_NA_1 -> m_ei_na_1: M_EI_NA_1_io(id)[id.nobj];
        TypeID::C_IC_NA_1 -> c_ic_na_1: C_IC_NA_1_io(id)[id.nobj];
        TypeID::C_CI_NA_1 -> c_ci_na_1: C_CI_NA_1_io(id)[id.nobj];
        TypeID::C_RD_NA_1 -> c_rd_na_1: C_RD_NA_1_xx(id)[id.nobj];
        # XXX: id.nobj must be 1 for C_CS_NA_1?
        TypeID::C_CS_NA_1 -> c_cs_na_1: C_CS_NA_1_io()[id.nobj] if (!id.sq);
        TypeID::C_RP_NA_1 -> c_rp_na_1: C_RP_NA_1_io(id)[id.nobj];
        TypeID::C_TS_TA_1 -> c_ts_ta_1: C_TS_TA_1_io(id)[id.nobj];
        TypeID::P_ME_NA_1 -> p_me_na_1: P_ME_NA_1_io(id)[id.nobj];
        TypeID::P_ME_NB_1 -> p_me_nb_1: P_ME_NB_1_io(id)[id.nobj];
        * -> raw: Raw(id.type_id, apdu.len - 10) &parse-at=self.start {
            self.set_input(self.start + (apdu.len - 10));
        }
    };
};

type Raw = unit(tid: TypeID, nbytes: uint8) {
    data: bytes &size=(nbytes) &convert=spicy::bytes_to_hexstring($$);

    on %init {
        self.type_id = tid;
    }

    var type_id: TypeID = tid;
};

################################################################################

function SIQ_rec(siq: SIQ): tuple<spi: bool, bl: bool, sb: bool, nt: bool, iv: bool>
{
    return (siq.spi == 1,
            siq.bl == 1,
            siq.sb == 1,
            siq.nt == 1,
            siq.iv == 1);
}

function DIQ_rec(diq: DIQ): tuple<dpi: uint8, bl: bool, sb: bool, nt: bool, iv: bool>
{
    return (diq.dpi,
            diq.bl == 1,
            diq.sb == 1,
            diq.nt == 1,
            diq.iv == 1);
}

function QD_rec(qd: QD): tuple<sq: uint8, cy: bool, ca: bool, iv: bool>
{
    return (qd.sq,
            qd.cy == 1,
            qd.ca == 1,
            qd.iv == 1);
}

function QDS_rec(qds: QDS): tuple<ov: bool, bl: bool, sb: bool, nt: bool, iv: bool>
{
    return (qds.ov == 1,
            qds.bl == 1,
            qds.sb == 1,
            qds.nt == 1,
            qds.iv == 1);
}

function SEP_rec(sep: SEP): tuple<es: uint8, ei: bool, bl: bool, sb: bool, nt: bool, iv: bool>
{
    return (sep.es,
            sep.ei == 1,
            sep.bl == 1,
            sep.sb == 1,
            sep.nt == 1,
            sep.iv == 1);
}

function QDP_rec(qdp: QDP): tuple<ei: bool, bl: bool, sb: bool, nt: bool, iv: bool>
{
    return (qdp.ei == 1,
            qdp.bl == 1,
            qdp.sb == 1,
            qdp.nt == 1,
            qdp.iv == 1);
}

function SEPstart_rec(ss: SEPstart): tuple<gs: bool, sl1: bool, sl2: bool, sl3: bool, sie: bool, srd: bool>
{
    return (ss.gs == 1,
            ss.sl1 == 1,
            ss.sl2 == 1,
            ss.sl3 == 1,
            ss.sie == 1,
            ss.srd == 1);
}

function OCI_rec(oci: OCI): tuple<gc: bool, cl1: bool, cl2: bool, cl3: bool>
{
    return (oci.gc == 1,
            oci.cl1 == 1,
            oci.cl2 == 1,
            oci.cl3 == 1);
}

function SCO_rec(sco: SCO): tuple<scs: bool, qu: uint8, se: bool>
{
    return (sco.scs == 1, sco.qu, sco.se == 1);
}

function DCO_rec(dco: DCO): tuple<dcs: uint8, qu: uint8, se: bool>
{
    return (dco.dcs, dco.qu, dco.se == 1);
}

function RCO_rec(rco: RCO): tuple<rcs: uint8, qu: uint8, se: bool>
{
    return (rco.rcs, rco.qu, rco.se == 1);
}

function QOS_rec(qos: QOS): tuple<ql: uint8, se: bool>
{
    return (qos.ql, qos.se == 1);
}

function VTI_rec(vti: VTI): tuple<val: int8, ts: bool>
{
    # Poor man's two's-complement, not sure how to make Spicy treat
    # the 7 value bits as signed integer.
    local x: int8;
    if (vti.val < 64) {
        x = int8(vti.val);
    } else {
        x = int8(-64) + int8(vti.val & 0x3f);
    }
    return (x, vti.ts == 1);
}

function QCC_rec(qcc: QCC): tuple<rqt: uint8, frz: uint8>
{
    return (qcc.rqt, qcc.frz);
}

function QPM_rec(qpm: QPM): tuple<kpa: uint8, pop: bool, lpc: bool>
{
    return (qpm.kpa, qpm.pop == 1, qpm.lpc == 1);
}

function CP56Time2a_rec(tt: CP56Time2a):
    tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>
{
    return (tt.ms, tt.minute, tt.iv == 1, tt.hour, tt.su == 1, tt.day, tt.dow, tt.month, tt.year);
}

function CP24Time2a_rec(tt: CP24Time2a):
    tuple<ms: uint16, minute: uint8, iv: bool>
{
    return (tt.ms, tt.minute, tt.iv == 1);
}

public function AsduIdent_rec(id: AsduIdent):
    tuple<type_id: TypeID, nobj: uint8, sq: bool, cot: CoT, pn: bool, test: bool, oa: uint8, ca: uint16>
{
    return (id.type_id, id.nobj, id.sq == 1, id.cot, id.pn == 1, id.test == 1, id.originator_address, id.common_address);
}

################################################################################

public function M_SP_NA_1_rec(io: M_SP_NA_1_io):
    tuple<uint64, tuple<spi: bool, bl: bool, sb: bool, nt: bool, iv: bool>>
{
    return (io.oa, SIQ_rec(io.siq));
}

public function M_SP_TA_1_rec(io: M_SP_TA_1_io):
    tuple<uint64,
          tuple<spi: bool, bl: bool, sb: bool, nt: bool, iv: bool>,
          tuple<ms: uint16, minute: uint8, iv:bool>>
{
    return (io.oa, SIQ_rec(io.siq), CP24Time2a_rec(io.tt));
}

public function M_DP_NA_1_rec(io: M_DP_NA_1_io):
    tuple<uint64, tuple<dpi: uint8, bl: bool, sb: bool, nt: bool, iv: bool>>
{
    return (io.oa, DIQ_rec(io.diq));
}

public function M_DP_TA_1_rec(io: M_DP_TA_1_io):
    tuple<uint64,
          tuple<dpi: uint8, bl: bool, sb: bool, nt: bool, iv: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool>>
{
    return (io.oa, DIQ_rec(io.diq), CP24Time2a_rec(io.tt));
}

public function M_ST_NA_1_rec(io: M_ST_NA_1_io):
    tuple<uint64, tuple<val: int8, ts: bool>, tuple<ov: bool, bl: bool, sb: bool, nt: bool, iv: bool>>
{
    return (io.oa, VTI_rec(io.vti), QDS_rec(io.qds));
}

public function M_ST_TA_1_rec(io: M_ST_TA_1_io):
    tuple<uint64,
          tuple<val: int8, ts: bool>,
          tuple<ov: bool, bl: bool, sb: bool, nt: bool, iv: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool>>
{
    return (io.oa, VTI_rec(io.vti), QDS_rec(io.qds), CP24Time2a_rec(io.tt));
}

public function M_BO_NA_1_rec(io: M_BO_NA_1_io):
    tuple<uint64, bsi: uint32, tuple<ov: bool, bl: bool, sb: bool, nt: bool, iv: bool>>
{
    return (io.oa, io.bsi, QDS_rec(io.qds));
}

public function M_BO_TA_1_rec(io: M_BO_TA_1_io):
    tuple<uint64, bsi: uint32,
          tuple<ov: bool, bl: bool, sb: bool, nt: bool, iv: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool>>
{
    return (io.oa, io.bsi, QDS_rec(io.qds), CP24Time2a_rec(io.tt));
}

public function M_ME_NA_1_rec(io: M_ME_NA_1_io):
    tuple<uint64, nva: uint16, tuple<ov: bool, bl: bool, sb: bool, nt: bool, iv: bool>>
{
    return (io.oa, io.nva, QDS_rec(io.qds));
}

public function M_ME_NB_1_rec(io: M_ME_NB_1_io):
    tuple<uint64, sva: uint16, tuple<ov: bool, bl: bool, sb: bool, nt: bool, iv: bool>>
{
    return (io.oa, io.sva, QDS_rec(io.qds));
}

public function M_ME_TB_1_rec(io: M_ME_TB_1_io):
    tuple<uint64, sva: uint16,
          tuple<ov: bool, bl: bool, sb: bool, nt: bool, iv: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool>>
{
    return (io.oa, io.sva, QDS_rec(io.qds), CP24Time2a_rec(io.tt));
}

public function M_ME_TA_1_rec(io: M_ME_TA_1_io):
    tuple<uint64, nva: uint16,
          tuple<ov: bool, bl: bool, sb: bool, nt: bool, iv: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool>>
{
    return (io.oa, io.nva, QDS_rec(io.qds), CP24Time2a_rec(io.tt));
}

public function M_ME_NC_1_rec(io: M_ME_NC_1_io):
    tuple<uint64, r32: real, tuple<ov: bool, bl: bool, sb: bool, nt: bool, iv: bool>>
{
    return (io.oa, io.r32, QDS_rec(io.qds));
}

public function M_ME_TC_1_rec(io: M_ME_TC_1_io):
    tuple<uint64, r32: real,
          tuple<ov: bool, bl: bool, sb: bool, nt: bool, iv: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool>>
{
    return (io.oa, io.r32, QDS_rec(io.qds), CP24Time2a_rec(io.tt));
}

public function M_IT_NA_1_rec(io: M_IT_NA_1_io):
    tuple<uint64, bcr: uint32,
          tuple<sq: uint8, cy: bool, ca: bool, iv: bool>>
{
    return (io.oa, io.bcr, QD_rec(io.qd));
}

public function M_IT_TA_1_rec(io: M_IT_TA_1_io):
    tuple<uint64, bcr: uint32,
          tuple<sq: uint8, cy: bool, ca: bool, iv: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool>>
{
    return (io.oa, io.bcr, QD_rec(io.qd), CP24Time2a_rec(io.tt));
}

public function M_PS_NA_1_rec(io: M_PS_NA_1_io):
    tuple<uint64, bcr: uint32,
          tuple<ov: bool, bl: bool, sb: bool, nt: bool, iv: bool>>
{
    return (io.oa, io.scd, QDS_rec(io.qds));
}

public function M_ME_ND_1_rec(io: M_ME_ND_1_io):
    tuple<uint64, nva: uint16>
{
    return (io.oa, io.nva);
}

public function M_SP_TB_1_rec(io: M_SP_TB_1_io):
    tuple<uint64,
          tuple<spi: bool, bl: bool, sb: bool, nt: bool, iv: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>>
{
    return (io.oa, SIQ_rec(io.siq), CP56Time2a_rec(io.tt));
}

public function M_DP_TB_1_rec(io: M_DP_TB_1_io):
    tuple<uint64,
          tuple<dpi: uint8, bl: bool, sb: bool, nt: bool, iv: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>>
{
    return (io.oa, DIQ_rec(io.diq), CP56Time2a_rec(io.tt));
}

public function M_ST_TB_1_rec(io: M_ST_TB_1_io):
    tuple<uint64,
          tuple<val: int8, ts: bool>,
          tuple<ov: bool, bl: bool, sb: bool, nt: bool, iv: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>>
{
    return (io.oa, VTI_rec(io.vti), QDS_rec(io.qds), CP56Time2a_rec(io.tt));
}

public function M_BO_TB_1_rec(io: M_BO_TB_1_io):
    tuple<uint64, bsi: uint32,
          tuple<ov: bool, bl: bool, sb: bool, nt: bool, iv: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>>
{
    return (io.oa, io.bsi, QDS_rec(io.qds), CP56Time2a_rec(io.tt));
}

public function M_ME_TD_1_rec(io: M_ME_TD_1_io):
    tuple<uint64, nva: uint16,
          tuple<ov: bool, bl: bool, sb: bool, nt: bool, iv: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>>
{
    return (io.oa, io.nva, QDS_rec(io.qds), CP56Time2a_rec(io.tt));
}

public function M_ME_TE_1_rec(io: M_ME_TE_1_io):
    tuple<uint64, sva: uint16,
          tuple<ov: bool, bl: bool, sb: bool, nt: bool, iv: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>>
{
    return (io.oa, io.sva, QDS_rec(io.qds), CP56Time2a_rec(io.tt));
}

public function M_ME_TF_1_rec(io: M_ME_TF_1_io):
    tuple<uint64, r32: real,
          tuple<ov: bool, bl: bool, sb: bool, nt: bool, iv: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>>
{
    return (io.oa, io.r32, QDS_rec(io.qds), CP56Time2a_rec(io.tt));
}

public function M_IT_TB_1_rec(io: M_IT_TB_1_io):
    tuple<uint64, bcr: uint32,
          tuple<sq: uint8, cy: bool, ca: bool, iv: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>>
{
    return (io.oa, io.bcr, QD_rec(io.qd), CP56Time2a_rec(io.tt));
}

public function M_EP_TD_1_rec(io: M_EP_TD_1_io):
    tuple<uint64, sep: SEP, ms: uint16,
          tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>>
{
    return (io.oa, io.sep, io.ms, CP56Time2a_rec(io.tt));
}

public function M_EP_TE_1_rec(io: M_EP_TE_1_io):
    tuple<obj_addr: uint64,
          sep: tuple<gs: bool, sl1: bool, sl2: bool, sl3: bool, sie: bool, srd: bool>,
          qdp: tuple<ei: bool, bl: bool, sb: bool, nt: bool, iv: bool>,
          ms: uint16,
          tt56: tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>>
{
    return (io.oa, SEPstart_rec(io.sep), QDP_rec(io.qdp), io.ms, CP56Time2a_rec(io.tt));
}

public function M_EP_TF_1_rec(io: M_EP_TF_1_io):
    tuple<obj_addr: uint64,
          oci: tuple<gc: bool, cl1: bool, cl2: bool, cl3: bool>,
          qdp: tuple<ei: bool, bl: bool, sb: bool, nt: bool, iv: bool>,
          ms: uint16,
          tt56: tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>>
{
    return (io.oa, OCI_rec(io.oci), QDP_rec(io.qdp), io.ms, CP56Time2a_rec(io.tt));
}

public function C_SC_NA_1_rec(io: C_SC_NA_1_io):
    tuple<uint64, tuple<scs: bool, qu: uint8, se: bool>>
{
    return (io.oa, SCO_rec(io.sco));
}

public function C_DC_NA_1_rec(io: C_DC_NA_1_io):
    tuple<uint64, tuple<dcs: uint8, qu: uint8, se: bool>>
{
    return (io.oa, DCO_rec(io.dco));
}

public function C_RC_NA_1_rec(io: C_RC_NA_1_io):
    tuple<uint64, tuple<rcs: uint8, qu: uint8, se: bool>>
{
    return (io.oa, RCO_rec(io.rco));
}

public function C_SE_NA_1_rec(io: C_SE_NA_1_io):
    tuple<uint64, nva: uint16, tuple<ql: uint8, se: bool>>
{
    return (io.oa, io.nva, QOS_rec(io.qos));
}

public function C_SE_NB_1_rec(io: C_SE_NB_1_io):
    tuple<uint64, sva: uint16, tuple<ql: uint8, se: bool>>
{
    return (io.oa, io.sva, QOS_rec(io.qos));
}

public function C_SE_NC_1_rec(io: C_SE_NC_1_io):
    tuple<uint64, r32: real, tuple<ql: uint8, se: bool>>
{
    return (io.oa, io.r32, QOS_rec(io.qos));
}

public function C_BO_NA_1_rec(io: C_BO_NA_1_io):
    tuple<uint64, bsi: uint32>
{
    return (io.oa, io.bsi);
}

public function C_SC_TA_1_rec(io: C_SC_TA_1_io):
    tuple<uint64, tuple<scs: bool, qu: uint8, se: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>>
{
    return (io.oa, SCO_rec(io.sco), CP56Time2a_rec(io.tt));
}

public function C_DC_TA_1_rec(io: C_DC_TA_1_io):
    tuple<uint64, tuple<dcs: uint8, qu: uint8, se: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>>
{
    return (io.oa, DCO_rec(io.dco), CP56Time2a_rec(io.tt));
}

public function C_RC_TA_1_rec(io: C_RC_TA_1_io):
    tuple<uint64, tuple<rcs: uint8, qu: uint8, se: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>>
{
    return (io.oa, RCO_rec(io.rco), CP56Time2a_rec(io.tt));
}

public function C_SE_TA_1_rec(io: C_SE_TA_1_io):
    tuple<uint64, uint16, tuple<ql: uint8, se: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>>
{
    return (io.oa, io.nva, QOS_rec(io.qos), CP56Time2a_rec(io.tt));
}

public function C_SE_TB_1_rec(io: C_SE_TB_1_io):
    tuple<uint64, uint16, tuple<ql: uint8, se: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>>
{
    return (io.oa, io.sva, QOS_rec(io.qos), CP56Time2a_rec(io.tt));
}

public function C_SE_TC_1_rec(io: C_SE_TC_1_io):
    tuple<uint64, real, tuple<ql: uint8, se: bool>,
          tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>>
{
    return (io.oa, io.r32, QOS_rec(io.qos), CP56Time2a_rec(io.tt));
}

public function C_BO_TA_1_rec(io: C_BO_TA_1_io):
    tuple<uint64, uint32,
          tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>>
{
    return (io.oa, io.bsi, CP56Time2a_rec(io.tt));
}

public function M_EI_NA_1_rec(io: M_EI_NA_1_io):
    tuple<uint64, coi: uint8, lpc: bool>
{
    return (io.oa, io.coi, io.lpc == 1);
}

public function C_IC_NA_1_rec(io: C_IC_NA_1_io):
    tuple<uint64, uint8>
{
    return (io.oa, io.qoi);
}

public function C_CI_NA_1_rec(io: C_CI_NA_1_io):
    tuple<uint64, qcc: tuple<rqt: uint8, frz: uint8>>
{
    return (io.oa, QCC_rec(io.qcc));
}

public function C_RD_NA_1_rec_a(io: C_RD_NA_1_io_a):
    tuple<uint64, optional<uint8>>
{
    return (io.oa, io.raw_data);
}

public function C_RD_NA_1_rec_b(io: C_RD_NA_1_io_b):
    tuple<uint64, optional<uint8>>
{
    return (io.obj_addr, Null);
}

public function C_CS_NA_1_rec(io: C_CS_NA_1_io):
    tuple<uint64,
          tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>>
{
    return (io.obj_addr, CP56Time2a_rec(io.tt),);
}

public function C_RP_NA_1_rec(io: C_RP_NA_1_io):
    tuple<uint64, qrp: uint8>
{
    return (io.oa, io.qrp);
}

public function C_TS_TA_1_rec(io: C_TS_TA_1_io):
    tuple<uint64, tsc: uint8,
          tuple<ms: uint16, minute: uint8, iv: bool, hour: uint8, su: bool, day: uint8, dow: uint8, month: uint8, year: uint8>>
{
    return (io.obj_addr, io.tsc, CP56Time2a_rec(io.tt));
}

public function P_ME_NA_1_rec(io: P_ME_NA_1_io):
    tuple<uint64, nva: uint16, tuple<kpa: uint8, pop: bool, lpc: bool>>
{
    return (io.obj_addr, io.nva, QPM_rec(io.qpm));
}

public function P_ME_NB_1_rec(io: P_ME_NB_1_io):
    tuple<uint64, sva: uint16, tuple<kpa: uint8, pop: bool, lpc: bool>>
{
    return (io.obj_addr, io.sva, QPM_rec(io.qpm));
}
